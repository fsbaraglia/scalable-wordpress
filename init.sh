#!/usr/bin/env bash

# Load the project variables into the current shell
source ./project.vars
PROJ_PATH=$(pwd)

# Check the arguments
if [[ ${#} -lt 1 ]]; then
    echo "Please define minimum one argument as the ENVIRONMENT name (e.g dev)!"
    echo "Initialization aborted."
    exit 1
fi

# Define the environment (dev,...,prod)
ENV=$1
ENV_PATH="${PROJ_PATH}/environments/${ENV}"
if [[ ! -d ${ENV_PATH} ]]; then
    echo "The environment '${ENV}' does NOT exist under 'environments' directory."
    echo "It will be created in the path '${ENV_PATH}'"
    echo "The config and variable files are automatically generated by the script. However, the variables in 'variables.tfvars' might need to be updated."
    echo "Additionaly, the DB secret parameters should be provided in the ${ENV_PATH}/.secrets"
fi

# The path of the ssh key for init module
KEY_NAME='ssh-key'
KEY_DIR="${ENV_PATH}/.secrets"
KEY_FILE="${KEY_DIR}/${KEY_NAME}"

# Define the variable arguments of TF command
VAR_ARG=" -var=aws_profile=${AWS_PROFILE} -var=aws_region=${AWS_REGION} \
    -var=env=${ENV} -var=project_name=${PROJECT} -var=ssh_key_file=${KEY_FILE}"

# Make sure the path is existing
mkdir -p ${KEY_DIR}

# Initialize Terraform on the init module
cd ${PROJ_PATH}/init
terraform init

# Select/create the workspace
terraform workspace list | grep $ENV
if [[ "${?}" -eq 0 ]]
then
    terraform workspace select $ENV
else
    terraform workspace new $ENV
fi

if [[ $2 == 'tf' ]]; then
  echo "terraform ${@:3} ${VAR_ARG}"
  terraform ${@:3} ${VAR_ARG}
  exit 0
fi

# Destroy if the arg was defined
if [[ $2 == 'destroy' ]]; then
    echo "The script was executed with DESTROY flag!"
    read -p "Do you really want to destroy all init resources? [Y/y]" -n 1 -r
    echo
    if [[ ! $REPLY =~ ^[Yy]$ ]]
    then
        exit 1
    fi
    echo "Executing: terraform destroy ${VAR_ARG}"
    terraform destroy ${VAR_ARG}
    rm -f ${KEY_DIR}/ssh-key*
    exit 0
fi

# Deploy the init resources
echo "Executing: terraform apply ${VAR_ARG}"
terraform apply ${VAR_ARG}

# Get required values to update the config file
TF_STATE_BUCKET=$(terraform show | grep terraform_state_bucket | cut -d= -f2 | tr -d ' "' | sed -E "s/[[:cntrl:]]\[[0-9]{1,3}m//g")
TF_STATE_LOCK=$(terraform show | grep terraform_state_dynamodb | cut -d= -f2 | tr -d ' "' | sed -E "s/[[:cntrl:]]\[[0-9]{1,3}m//g")

# Create the config file if not existing
CONFIG_FILE="${ENV_PATH}/backend.config"
if [[ ! -e ${CONFIG_FILE} ]]; then
  echo
  CONFIG_DATA="bucket = \"${TF_STATE_BUCKET}\"\nkey = \"terraform.tfstate\"\ndynamodb_table = \"${TF_STATE_LOCK}\"\nprofile = \"${AWS_PROFILE}\""
  echo -e ${CONFIG_DATA} > ${CONFIG_FILE}
  echo "The file 'backend.config' was created in the path ${ENV_PATH}"
fi

# Create variables file if not existing
if [[ ! -e ${ENV_PATH}/variables.tfvars ]]; then
    cat <<EOF > ${ENV_PATH}/variables.tfvars
env = "${ENV}"
region = "${AWS_REGION}"
tags = {
  Environment = "${ENV}"
  Project     = "${PROJECT}"
}

# All vpc resources including subnets, gateways and routings are provisioned.
# if vpc resources are already existing, then uncomment these variables
# and define proper values.
# create_vpc = false
# vpc_id = ""
# private_subnets = ""
# public_subnets = ""

# if the bastion host is not needed, uncomment this variable
# create_bastion = false

# if https listener is required for the ALB, uncomment 'enable_alb_https = true', and define 'certificate_arn'
# enable_alb_https = true
# certificate_arn = ""

# if additional IPs required ssh access. The public ip of the current user (var.my_ip) fetched automatically.
# custom_ips = []

# These two variables are defined via deploy script
# ssh_pub_key = ""
# userdata = ""
EOF

echo "The file 'variables.tfvars' was created in the path ${ENV_PATH}"
fi

# Create secret var file if not existing
SEC_PATH="${ENV_PATH}/.secrets"
SEC_FILE="${SEC_PATH}/secrets.tfvars"
if [[ ! -e ${SEC_FILE} ]]; then
  SEC_PARAMS='master_username = "DB_USER"\nmaster_password = "DB_PASS"'
  mkdir -p ${SEC_PATH}
  echo -e ${SEC_PARAMS} > ${SEC_FILE}
fi

# END OF SCRIPT
